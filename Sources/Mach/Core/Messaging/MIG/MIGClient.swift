import Darwin.Mach
import Foundation

extension Mach {
    /// A client for MIG requests.
    open class MIGClient: Mach.Port {
        /// The base routine ID for the remote MIG subsystem.
        open var baseRoutineID: mach_msg_id_t = 0

        /// Represents an existing MIG client port.
        public convenience init(named name: mach_port_name_t, baseRoutineID: mach_msg_id_t) {
            self.init(named: name)
            self.baseRoutineID = baseRoutineID
        }

        /// Performs a MIG routine.
        @discardableResult
        public func doRoutine(
            _ routineIndex: mach_msg_id_t,
            request: MIGRequest<some Mach.MIGPayload>,
            replyPort: Mach.Port? = nil,
            serverErrorDomain: String? = nil
        ) throws -> MIGReply<Never> {
            try self.doRoutine(
                routineIndex,
                request: request,
                replyPayloadType: Never.self,
                replyPort: replyPort
            )
        }

        /// Performs a MIG routine.
        @discardableResult
        public func doRoutine<ReplyPayload: Mach.MIGPayload>(
            _ routineIndex: mach_msg_id_t,
            request: MIGRequest<some Mach.MIGPayload>,
            replyPayloadType: ReplyPayload.Type = ReplyPayload.self,
            maxReplySize: Int = Mach.Message.defaultMaxReceiveSize,
            replyPort: Mach.Port? = nil,
            serverErrorDomain: String? = nil
        ) throws -> Mach.MIGReply<ReplyPayload> {
            let routineID = self.baseRoutineID + routineIndex
            request.header.msgh_id = routineID
            let reply = try Mach.Message.send(
                request,
                // We make a copy of the send right so we can reuse the port.
                to: self, withDisposition: .copySend,
                receiving: Mach.MIGReply<ReplyPayload>.self, ofMaxSize: maxReplySize,
                // We make a send-once right so we can receive the reply.
                from: replyPort ?? Mach.MIGReplyPort(), withDisposition: .makeSendOnce
            )

            // The below checks are made by client code generated by the MIG compiler, so we make them too.

            guard reply.header.msgh_id != MACH_NOTIFY_SEND_ONCE else {
                // The server deallocated the send-once right without using it, assume it died.
                throw Mach.MIGError(.serverDied)
            }
            guard reply.header.msgh_id == routineID + 100 else {
                // The reply ID should be the request ID + 100.
                throw Mach.MIGError(.replyMismatch)
            }
            guard reply.header.remotePort == Mach.Port.Nil else {
                // The reply should clear the remote port.
                throw Mach.MIGError(.typeError)
            }

            // If the reply is not complex and the same size as a MIG reply error, we
            // assume it is a reply error and parse it as such.
            if !reply.header.bits.isMessageComplex
                && reply.header.msgh_size == MemoryLayout<mig_reply_error_t>.size
            {
                try reply.serialize().withMemoryRebound(to: mig_reply_error_t.self, capacity: 1) {
                    let replyError = $0.pointee
                    // The name "reply error" is actually a bit of a misnomer. If the return code
                    // is `KERN_SUCCESS`, there was no error. We return early in this case.
                    if replyError.RetCode == KERN_SUCCESS { return }

                    // If the return code is a MIG error code, we throw a MIG error.
                    if let matchingMIGErrorCode = Mach.MIGErrorCode.allCases
                        .first(where: { $0.rawValue == replyError.RetCode })
                    {
                        // The `noReply` case is not actually an error, just the absence of
                        // a defined reply. We return early as if there was no error.
                        if matchingMIGErrorCode == .noReply { return }

                        // Otherwise, we throw a MIG error.
                        throw Mach.MIGError(matchingMIGErrorCode)
                    }

                    // If it's not a MIG error code, we throw a generic error with (if available)
                    // the user-provided error domain.
                    throw NSError(
                        domain: serverErrorDomain ?? "", code: Int(replyError.RetCode)
                    )
                }
            }
            return reply
        }
    }
}

extension Mach.ClientInitializableByServiceName where Self: Mach.MIGClient {
    /// Obtains a MIG client for the given service.
    public init(serviceName: String, baseRoutineID: mach_msg_id_t) throws {
        try self.init(serviceName: serviceName)
        self.baseRoutineID = baseRoutineID
    }
}
